第二章 着色语言
====
## 1. 着色言概述
> OpenGL ES 着色语言是一种高级的图形编程语言，其源自广泛应用的C语言、同时具有RenderMan以及其它着色语言的一些优良特性，易于被开发人员掌握。

>与传统通用的编程语言有很大不同的是，其提供了更加丰富的原生类型，如向量、矩阵等，这些新特性的加入使得OpenGL ES 着色语言在处理3D图形方面更加高效、易用。简单来说,OpenGL ES 着色语言主要包括以下特性.
+ OpenGL ES 着色语言是一种的过程性语言（注意:不是面向对象）
+ 对定点着色器、片元着色器使用的是同样的语言，不做区分
+ 基于c/c++的语法及流程控制
+ 完美支持向量与矩阵的各种操作
+ 通过类型限定符来管理输入与输出
+ 拥有大量的内置函数来提供丰富的功能

总之,OpenGL ES 着色语言是一种易于实现、功能强大、便于使用、完美支持硬件灵活性，并且可以高度并行处理、性能优良的高级图形编程语言。其可以帮助开发人员在不浪费大量的时间的情况下，轻松地为用户带来更加完美的视觉体验，开发出更加酷炫的3D场景与特效。

对于3D游戏开发人员来说，掌握这门语言尤为重要。本章的后继美容将从多个方面介绍OpenGL ES 着色语言的基本知识，使得读者初步了解着色语言，为以后深入地学习打下坚实的基础.

## 2. 着色语言基础
OpenGL ES 着色语言虽然是基于c/c++语法的语言，但是其余c/c++ 相比较还是有很大不同的。例如，该语言不支持双精度浮点型(double)、字节型(byte)、短整型(short)、长整型（long），并且取消了C语言中的联合体（union）、枚举类型（enum）、无符号整型（unsigned）以及位运算等特性。

### 2.1 数据类型概述
与C语言类似，着色语言中有许多内建的原生数据类型，如浮点型(float)、布尔类型(bool)、整型(int)、矩阵型(matrix)以及向量类型(vec2,vec3等)等。总体来说，这些数据可以分为标量、向量、矩阵、采样器、结构体以及数组等几类。
#### 2.1.1 标量
标量也被称为“无向量” ，其值只具有大小，并不具有方向。标量之间的运算遵循简单的代数法则，如质量、密度、体积、时间以及温度等都属于标量。OpenGL ES 着色语言支持的标量类型有bool、int、float,各自的用法如下所列。
* 布尔型----bool<br><br>
`布尔型用来声明一个单独的布尔数，其值只能为true与false中的一个，bool类型的值一般由关系运算或者逻辑运算产生，在着色语言的流程控制中只能使用布尔类型的值作为表达式，其基本用法如下所示:`
```C
bool b;//声明一个布尔类型的变量
```
* 整型----int<br><br>
`整型用来声明一个单独的整数，其值可以为正数，负数及0。与c语言的整型有所不同，在OpenGL ES 着色语言中的整数保证最少支持16位精度。开发时注意运算需要在正确的范围内进行(若16位精度范围为[-65535~65536],着色语言中所谓的精度不含符号位)，超出运算范围可能产生溢出问题.`<br><br>
`OpenGL ES着色语言中整数也可以像C语言中一样，用十进制、八进制、或者十六进制等不同的进制表示，基本用法如下所示:`
  ```C
  int a=15;//十进制
  int b=036;//0开头的字面常量为八进制，代表十进制的30
  int c=0x3D;//0x开头的字面常量为十六进制，代表十进制的58
  ```
* 浮点型---float<br><br>
`浮点型用来声明一个单独的浮点数、基本用法如下所示。`
```C
  float f;//声明一个float型的变量
  float g=2.0;//在声明变量的同时为变量赋值
  float h,i;//同时声明多个变量
  float j,k=2.561;//声明多个变量时，可以为其中某些变量赋初值
```
 需要注意的是，由于OpenGL ES着色语言中没有像C/C++语言一样提供多种不同精度的整数与浮点数，因此代码中字面常量就不需要使用后缀来说明精度了，只要给出值即可。

#### 2.1.2 向量
OpenGL ES着色语言中，向量可以看做是用同样类型的标量组成的，其基本类型也分为bool、int、float 3种。每个向量就可以由2个、3个或者4个相同的标量组成,具体情况如下

|向量类型|说明|向量类型|说明|
|-|-|-|-|
|vec2|包含了2个浮点数的向量|ivec4|包含了4个整数的向量|
|vec3|包含了3个浮点数的向量|bvec2|包含了2个布尔数的向量|
|vec4|包含了4个浮点数的向量|bvec3|包含了3个布尔数的向量|
|ivec2|包含了2个整数的向量|bvec4|包含了4个布尔数的向量|
|ivec3|包含了3个整数的向量| | | |
+ 声明向量类型的基本语法如下.
```C
vec2 v2;//声明一个vec2类型的向量
ivec3 v3;//声明一个ivec3类型的向量
vec4 v4;//声明一个bvec4类型的向量  
```
+ 向量在着色器代码中开发中有着十分重要的作用，可以很方便地存储以及操作颜色、位置、纹理坐标等不仅包含一个组成部分的量。开发中，有时也可能需要单独访问想向量中的某个分量买几本的语法为"<向量名>.<分量名>"，根据目的的不同，主要有以下几种用法。<br><br>
+ 将一个向量看做颜色是，可以使用r、g、b、a 4个分量名，其分别代表红、绿、蓝、透明度4个色彩通道，具体用法如下。
```C
aColor.r=0.6;//给向量aColor的红色通道分量赋值
aColor.g=0.8;//给向量aColor绿色通道分量赋值
```
`若向量是4维的，则可以使用的分量名为:r、g、b、a；若向量是3维的，则可以使用的分量名为r、g、b；若为2维的，则可以使用r、g。`

+ 将一个向量看做位置时，可以使用x、y、z、w等四个分量名，其分表代表X轴、Y轴、Z轴、向量的4个分量，具体用法如下。<br>
```C
aPosition.x=67.2;//给向量aPosition的X轴分量赋值
aPosition.z=48.3;//给向量aPosition的z轴分量赋值
```
`若向量是4维的，则可以使用的分量名为:x、y、z、w；若向量是3维的，则可以使用的分量名为x、y、z；若为2维的，则可以使用x、y。`

+ 将一个向量看做纹理坐标时，可以使用s、t、p、q等4个分量名，其分别代表纹理坐标的不同分量，具体用法如下。<br>
```C
aTexCoor.s=0.65;//给向量aTexCoor的s分量赋值
aTexCoor.t=0.34;//给向量aTexCoor的t分量赋值
```
`若向量是4维的，则可以使用的分量名为:s、t、p、q；若向量是3维的，则可以使用的分量名为s、t、p；若为2维的，则可以使用s、t。`
+ 访问向量中的各个分量不但可以采用“.”加上不同的分量名，还可以将向量看做一个数组，用下标来进行访问，具体用法如下.
```C
aColor[0]=0.6;//给向量aColor红色通道分量赋值
aPosition[2]=48.3;//给向量aPosition的z轴分量赋值
aTexCoor[1]=0.34;//给向量aTexCoor的t分量赋值
```

#### 2.1.3 矩阵
有一些基础的开发人员都知道，3D场景中的移位，旋转，缩放等变换都是由矩阵的运算都实现的。因此3D场景的开发中会非常多地使用到矩阵，因此OpenGL ES着色语言中也提供了对矩阵类型的支持。这大大方便了开发，免去了自行构建矩阵的麻烦.

+ 矩阵按尺寸分为2x2矩阵，3x3矩阵以及4x4矩阵，具体情况如下表所列:

|矩阵类型|说明|
|---|---|
|mat2|2x2的浮点数矩阵|
|mat3|3x3的浮点数矩阵|
|mat4|4x4的浮点数矩阵|
+ 矩阵类型的基本用法如下.
  ```C
  mat2 m2;//声明一个mat2类型的矩阵
  mat3 m3;//声明一个mat3类型的矩阵
  mat4 m4;//声明一个mat4类型的矩阵
  ```
OpenGL ES 着色语言中，矩阵是按列顺序组织的.
也就是一个矩阵可以看做由几个列向量组成。
例如:mat3就可以看作由3个vec3组成


#### 2.1.4 采样器
采样器是着色语言中不同于C语言的一种特殊的基本数据类型，其专门用来进行纹理采样的相关操作。一般情况下，一个采样器变量代表一副或一套纹理贴图，其具体情况如下表所列

|采样器类型|说明|采样器类型|说明|
|-|-|-|-|
|sampler2d|用于访问二维纹理|sampleCube|用于访问立体贴图纹理|
|sampler3d|用于访问三维纹理| | | |

`需要注意的是，采样器变量不能在着色器中初始化。一般情况下采样器变量都用uniform限定符修饰，从宿主语言(如:java)接收传递进着色器的值`<br><br>
`sampler3d并不是在所有的OpenGL ES实现中都支持，因此，若要使用必须首先
  着色器代码中进行设置，打开相应的扩展.`

#### 2.1.5 结构体
+ `OpenGL ES 着色语言还提供了类似于C语言中的用户自定义结构体，同样是使用struct关键字进行声明，基本用法如下所示.`
  ```C
  struct info {//声明一个结构体info
    vec3 color;//颜色成员
    vec3 position;//位置成员
    vec2 textureCoor;//纹理坐标成员
  }
  ```
+ 声明了info类型的结构体之后，就可以像使用内建数据类型一样使用这个用户自定义的类型了，如:<br>
```C
info CubeInfo;//声明了一个info类型的变量CubeInfo
```  

#### 2.1.6 数组
声明数组的方式主要有两种，具体如下所列:
+ 在声明数组的同时，指定数组的大小
  ```C
  vec3 position[20];//声明了一个包含20个vec3的数组，索引从0开始
  ```
+ 在声明数组时，也可以不指定数组的大小，但是必须符合下列相中情况之一.<br><br>
(1). 引用数组之前，要再次使用第一种声明方式来声明该数组，代码如下.
```C
vec3 position[];//声明了一个大小不定的vec3数组
vec3 position[5];//再次声明该数组，并且指定大小
```
`再次声明数组，指定大小之后，就不能再进行声明了`<br><br>
(2). 代码中访问数组的下标都是编译时常量（如:字面常量），这时编译器就会自动创建适当大小的数组，使得数组尺寸足够存储编译器看到的最大索引值对应的元素，代码如下:
```C
vec3 position[];//声明了一个大小不定的vec3型数组
position[3]=vec3(3.0);//position需要一个大小为4的数组
position[20]=vec3(6.0);//position需要一个大小为21的数组
```
`上述代码中的第2行需要尺寸为4的数组，代码的地3行需要尺寸为21的数组，若后面没有更大的下标出现，则编译器自动创建position为尺寸为21的数组。这种由系统量体裁衣，自动分配的方法若恰当使用可以提高硬件的使用效率，降低对硬件资源的消耗。`

#### 2.1.7 空类型
空类型使用void表示，仅用来声明不返回任何值的函数。例如在顶点着色器以及片元着色器中必须存在的main函数就是一个返回值为空类型的函数，代码如下所示.
```C
void main() {

//函数的具体操作省略...
}
```

### 2.2 数据类型的基本使用
前一小节介绍了OpenGL ES着色语言中的各个数据类型，掌握了这些数据类型的基本知识后，本节将简单地介绍这些数据类型的声明，初始化以及作用域.<br><br>
1. 声明、作用域及初始化<br>
`变量的声明及作用域与C++语法类似，可以在任何需要的位置声明变量，同时其作用域也与C++类似，分为局部变量与全局变量。请读者考察如下代码片段。`
```C
int a,b;//声明了全局变量a及b
vec3 aPosition=vec3(1.0,2.0,3.3);//声明了全局变量aPosition并赋初值
void myFunction(){
      int c=14;//声明了局部变量C并赋初值
      a=4;//给全局变量a赋值
      b=a*c;//给全局变量b赋值
}
```
`着色语言还有一点特殊的地方，在一些着色语言的实现中不可以在if语句中声明新的变量，这是为了简化变量在else子句上的作用域的实现。目前的Android平台的各种实现基本都是在支持在if语句中声明变量的，但也不排除有特殊的情况出现，了解这一点即可。`<br><br>
`虽然着色器中变量的命名很自由，仅要求变量由字母，数字与下划线组成，且必须以字母或者下划线开头。但开发人员在开发程序时，有一个良好的命名习惯将大大提高代码的可维护性，同时使得开发的代码简介、美观、可读性强。因此，建议在OpenGL ES着色语言中，变量按照如下规则命名.`<br><br>
 + 由于系统中有很多内建变量都是以“gl_”作为开头，因此用户自定义的变量不允许使用“gl_”作为开头.
 + 为自己的函数或变量取名时尽量采用有意义的拼写，除了一些局部变量外不要采用a、b、c这样的名称。若一个单词不足以描述变量的用途，可以用单个单词的组合，除第一个单词全小写外，其他每个单词的第一个字母大写.

 + `向量的初始化还有一些灵活变化的技巧，下面的代码片段说明了这个问题.`
```C
float a=12.3;//声明了浮点变量a并赋初值
float b=11.4;//声明了 浮点变量b并赋初值
vec2 va=vec2(2.3,2.5);//声明了2维向量va并赋初值
vec2 vb=vec2(a,b);//声明了2维向量vb并赋初值
vec3 vc=vec3(vb.13.5);//声明了3维向量vc并赋初值
vec4 vd=vec4(va,vb);//声明了4维向量vd并赋初值
vec4 ve=vec4(0.2);//声明了4维向量ve并赋初值，相当于vec4(0.2,0.2,0.2,0.2)
```
从上诉代码中可以看出，初始化时向向量的各个分量既可以使用字面常量，也可以使用变量，还可以从其他向量直接获取。同时，若向量个分量的值相同，还可以采用第7行代码所示的简化语法。实际开发中，读者可以根据具体情况选用.
 + 矩阵的初始化也有一些灵活变化的技巧，下面的代码片段说明了这个问题。
```C
float a=6.3;//声明了浮点变量a并赋初值
float b=11.4;//声明了浮点变量b并赋初值
float c=12.5;//声明了浮点变量c并赋初值
vec3 va=vec3(2.3,2.5,3.8);
vec3 vb=vec3(a,b,c);
vec3 vc=vec3(vb.x,vb.y,14.4);
mat3 ma=mat3(1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,c);//通过给出的9个字面常量初始化3x3的矩阵
mat3 mb=mat3(va,vb,vc);//通过给出3个向量初始化3x3的矩阵
mat3 mc=mat3(va,vb,1.0,2.0,3.0);//通过给出2个向量和3个字面常量初始化3x3的矩阵
mat3 md=mat3(2.0);//通过给出1个字面常量初始化3x3的矩阵
```
`从上述代码中可以看出，初始化时矩阵的各个元素既可以使用字面常量，也可以使用变量，还可以从其他向量直接获取。同时，若矩阵只有对角线上有值且相同，还可以采用如最后一行代码所示的简化语法进行初始化，其等同于mat3(2.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,2.0)。`<br><br><br>
2. 变量初始化的规则
该语言中的变量初始化规则基本承袭自C语言，但也有一些不同，基本规则如下所列.<br><br>
  + 常用初始化方式:变量可以在声明的时候进行初始化
  ```C
  int a=2,b=3,c;//声明了int型的变量a,b与c，同时为a与b变量赋初始值
  ```
  + 用const限定符修饰的变量必须在声明的时候进行初始化
  ```C
const float k=1.0;//在声明的时候初始化
  ```
  + 属性变量、一直变量以及易变变量在声明的时候一定不能进行初始化
  ```C
  attribute float angleSpan;//不可对属性变量进行初始化
  unifrom int k;//不可对一致变量进行初始化
  varying vec3 position;//不可对易变变量进行初始化
  ```

### 2.3 运算符
运算符列表（按照优先级顺序排列）

  * 下表中的运算符安装先从左到右，再从上到下的顺序

|运算符|说明|运算符|说明|
|---|---|---|---|
|[]|用于索引|.|用于成员选择与混合|
|++ --|自加1与自减1后缀|++ --|自加1与自减1前缀|
|- !|一元非与逻辑非|* /|乘法与除法|
|+ -|加法与减法|<> <= >=|关系运算符|
|== !=|等于以及不等于|&&|逻辑与|
|^^|逻辑异或|&#124;&#124;|逻辑或|
|?:|选择|= += -= *= /=|赋值运算符|

1. 索引

 着色语言中的索引表示方法与C语言中是完全相同的，用"[]" 来表示。并且在OPenGL ES着色语言中，索引的起始下标也为0。

 索引经常用在对数组、向量或者矩阵的操作中，通过索引操作，可以方便地获取数组、向量或者矩阵中包含的各种元素，具体使用如下面的代码片段所示.

 ```C
float array[10]; //声明一个大小为10的float数组
array[2]=1.0;//通过索引操作拿到下标为2的数，并且给其赋值
vec3 position=vec3(2.3,5.0,0.2);//声明一个vec3类型的向量，并且进行初始化
float temp=position[1];//通过索引对position向量进行操作，拿到其第二个数组5.0并赋值给temp
mat4 matrix=mat4(1.0);//声明一个mat4类型的矩阵，并进行初始化
vec4 tempv=matrix[1];//通过索引对matrix矩阵进行操作，拿到向量(0.0,1.0,0.0,0.0)并赋值给tempV
```

2. 混合选择

  通过运算符"."可以进行混合选择操作，在运算符"."之后列出一个向量中需要的各个分量的名称，就可以选择并重新排列这些分量。下面的代码片元说明了这个问题。
```C
vec4 color=vec4(0.7,0.1,0.5,1.0);//声明一个vec4类型的向量Color
vec3 temp=color.agb;//相当于拿到一个(1.0,0.1,0.5)并赋值给temp
vec4 temp:=color.aabb;//相当于拿到一个向量(1.0,1.0,0.5,0.5)赋值给tempL
vec3 tempLL;//声明了一个3维向量tempLL
tempLL.grb=color.aab;//对向量tempLL的3个分量赋值
```
 + 一次混合最多只能列出4个分量名称，且一次出现的各部分的分量名称必须是来自同一名称租。3个名称租分别为:xyzw、rgba、stpq，如:aColor.xa就是错误的，因为分量名称没有来自同一个组。  

 + 各分量的名称在进行混合时可以改变顺序以进行重新排列

 + 以赋值表达式中的"="为界，其左侧称之为L值（要写入的表达式）,右侧称之为R值（所读取的表达式）。进行混合时，R值可以使用一个向量的各个分量任意地组合以及重复，而L值则不能有任何的重复分离，但可以改变分量顺序。

3. 算术运算符

  自加以及自减运算符"++与--"执行的操作与C语言中相同，即可以用于整数也可以用于浮点数。若在向量以及矩阵中使用，则向量或矩阵的每个元素都加1或者减1.

  对标量而言，加减乘法运算与C语言基本没有区别。但若是对矩阵运算，则进行的是线性代数中的相关运算。如在矩阵上使用乘法时，执行的不再是简单的算术运算，而是线性代数的乘法。下面的代码片段说明了这些特殊的情况.

  ```C
  vec3 va=vec3(0.5,0.5,0.5);//声明了一个vec3向量va
  vec3 vb=vec3(2.0,1.0,4.0);//声明了一个vec3向量vb
  vec3 vc=va*vb;//两个向量执行按分量的乘法，加减与之类似
  mat3 ma=mat3(1,2,3,4,5,6,7,8,9);//声明了一个mat3的矩阵ma
  mat3 mb=mat3(9,8,7,6,5,4,3,2,1);//声明了一个mat3的矩阵mb
  ve3 vd=va*ma;//执行向量与矩阵的乘法，满足线性代数的定义
  mat3 mc=ma*mb;//执行矩阵的乘法，满足线性代数的定义
  ```
  + 向量用算术运算符运算时，执行的任务是各分量的算术运算，如将两个向量用"+"相加，实际执行的是各分量的相加得到的一个新的向量（用向量的各个数分别乘矩阵第1列的各个数 之 和 得新向量的第1列的数）

  + 关于向量与矩阵以及矩阵与矩阵的乘法都是执行的满足线性代数定义的运算。
  `向量可以看做是只有一行的特殊矩阵，所以也遵从矩阵与矩阵的乘法规律，公式如下:`

  > 设A为 m x p的矩阵，B为p x n  的矩阵，那么称 m x n的矩阵C为矩阵A与B的乘积，记作 C=AB ，其中矩阵C中的第 i行第 j 列元素可以表示为：

  ![](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D334/sign=5e0cfe86de33c895a27e9e78e5137397/8ad4b31c8701a18bd6fe9b5e992f07082838fe8e.jpg)<br> 如下所示:<br>

  ![](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D594/sign=01474d246759252da7171d0d009a032c/adaf2edda3cc7cd955ae9be73e01213fb80e9109.jpg)

### 2.4 类型转换
### 2.5 限定符
### 2.6 流程控制
### 2.7 函数的声明与使用
### 2.8 片元着色器中的浮点变量精度的指定
### 2.9 流程的基本结构
## 3. 特殊的内建变量
### 3.1 顶点着色器中的内建变量
### 3.2 片元着色器中内建变量
## 4. 着色器语言内置函数
### 4.1 着色器语言的内置函数
### 4.2 指数函数
### 4.3 常见函数
### 4.4 几何函数
### 4.5 矩阵函数
### 4.6 向量关系函数
### 4.7 纹理采样函数
### 4.8 微分函数
## 5. 本章小结
